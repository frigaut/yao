<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>yao::home</title>
<script type="text/javascript" src="scripts.js">void=null;</script>
<link rel="stylesheet" href="styles.css" type="text/css">
</head>
<body>

<div id="left-column"><img src="images/kbkheaderleft.jpg"></div>
<div id="right-column"><img src="images/kbkheaderright.jpg"></div>

<div id="center">
  
 <div id="banner">yao::home</div>

<div id="links2">
  <a href="index.html">HOME</a> &nbsp; | &nbsp;
  <a href="installation.html">INSTALL</a> &nbsp; |  &nbsp; 
  <a href="manual.html">MANUAL</a> &nbsp;  | &nbsp; 
<!--   <a href="screenshots.html">SCREENSHOTS</a> &nbsp;  | &nbsp;  -->
  <a href="news.html">NEWS</a> 
  </div>



  <div id="container">
   <h2>Introduction</h2>
   
   These pages present information about <b>yao</b>, a Monte-Carlo simulation tool for Adaptive optics (AO) systems.
   <b>Yao</b> is open source released under the GPLv3. You are welcome
   to use it, expand it and even distribute it, but please link back
   to this page, as I am releasing updates semi-regularly. The last
   version of yao to date (June 2010) is 4.5.2. <a name="features" id="features"></a></p>
 
   <h2>Main features</h2>

   <a href="images/yao_mcao_gui.png"><img src="images/yao_mcao_gui.png" width="35%"  class="imglink" style="float:right;" /></a>
   <b>Yao</b> is a Monte-Carlo AO simulation tool. It uses a number of custom developed functions to simulate wavefront sensors (WFS), deformable mirrors (DM) and many other aspects of an AO loop.
   
   
   <h3>Highlights</h3>
   <ul class="spaced">

     <li><font class="highlight">Coded in <a href="http://yorick.sourceforge.net">yorick</a></font>, a open source scripting language similar to IDL or mathlab (powerful and free!). The core, CPU intensive routines are coded in C. Yorick and the YAO plugins are written in ANSI-C, which makes them portable on many platforms. YAO should run on any *nix platform, including Linux, Mac OsX, BSD, cygwin, etc... It may also work on windows, but I have never tried.</li>

     <li>
       <font class="highlight">Shack-Hartmann</font>,
       <font class="highlight">Curvature</font> and
       <font class="highlight">Modal</font> (Zernike) 
       <font class="highlight">WFS</font>,
       ON or OFF axis, are supported. It is also possible  to <font class="highlight">add your own WFS</font> <font class="new">NEW</font>.
     </li>
     <li>
       <font class="highlight">Stackarray</font> (piezostack), 
       <font class="highlight">curvature</font> (bimorph), 
       <font class="highlight">segmented</font> <font class="new">NEW</font>, (experimental), 
       <font class="highlight">modal</font> (zernike or KL) and 
       <font class="highlight">Tip-Tilt deformable mirrors</font> 
       are supported. The altitude of conjugation is adjustable. It is also possible  to <font class="highlight">add your own DM</font> <font class="new">NEW</font>.
     </li>
     <li>An <font class="highlight">arbitrary number of WFSs and DMs</font> can be used, with the possibility of mixing types. It is therefore possible  to simulate single DM systems, as well as single non-zero conjugate, GLAO and MCAO systems.
     </li>
     <li>It supports <font class="highlight">Natural and Laser Guide Stars</font> (or a mix).
     </li>
     <li>It supports <font class="highlight">photon and read-out noise</font>.
     </li>
     <li>It uses a multi-layered atmospheric model, with geometrical propagation only.
     </li>
     <li>The loop execution has been <font class="highlight">optimized for speed</font>: the critical routines have been coded in C. Yorick is thus used as a convenient "glue" between lower levels optimized C calls. Overall, this is rather efficient: A simple 6x6 Shack-Hartmann system (geometrical model, no diffraction) runs at <font class="highlight">over a 1000 iterations/seconds</font> on modern machines (about 250it/sec for a full diffractive SHWFS). That's including turbulent phase computation, wavefront sensing, reconstruction, calculation of the DM shape and PSF/performance estimation.
       A 50x50 Shack-Hartmann (full diffraction model) system runs at about 10 iterations/s for an 8-m telescope. A 188 curvature system runs at over 40 iterations/s (see the <a href="news.html#breaking_the_1000itpersec_barrier">this entry</a> for more details). Medium-size AO systems for ELTs can also be simulated, but it takes more time and RAM (a 60x60 SH on a 960 pixel pupil runs at about 1 iteration/s and takes up to 2GB of RAM at peak usage). 
     </li>
     <li>Straightforward <font class="highlight">scriptability</font> to probe parameter space.
     </li>
     <li>An (optional) GTK <font class="highlight">GUI</font> provides a convenient interface. One can, e.g., change some of the system parameters <font class="highlight">while the loop is running</font>. This provides an educational approach to Adaptive Optics (newbies can play with the parameters and immediately sees how the system reacts) and can also provides a quick way to investigate the stability conditions for a newly designed system, before entering more serious Monte-carlo simulations. Note that because the GUI is GTK-based, it requires the gnome libraries. These come automatically in Linux and BSD, but are a bit more challenging to install on OsX (but possible with <a href="http://www.macports.org/">macport</a> or <a href="http://www.finkproject.org/">fink</a>). Note that the GUI is not essential to run YAO.
     </li>
   </ul>
   <h3>Other capabilities</h3>
   <ul class="spaced">
     <li>Arbitrary aperture shape (defined through a user plugin). Disk with central obstruction is the stock pupil, but examples are provided to create segmented or GMT like pupils.</li>
     <li>Partitioning of DMs and WFSs in independent subsystems (e.g. for separate control of TT in LGS systems)
     </li>
     <li>2 methods for Shack-Hartmann:
       <ol>
         <li>Simple gradient average, no noise, very fast: This allow to do tests of the noiseless performance of a system, for quick performance evaluation of system dimensioning
         </li>
         <li>Full propagation, with subaperture image formation. Includes adjustable subaperture and pixel size, photon and read-out noise, bias and flat field errors, thresholding, convolution by a gaussian kernel and image elongation in the case of LGS. Proper overlap between subapertures and possibility to put a field stop with adjustable shape, size and position <font class="new">NEW</font> .
         </li>
       </ol>
     </li>
     <li>Separately adjustable integration time for each sensor</li>
     <li>Adjustable frame delay (in integer unit of the quantum loop time)</li>
     <li>Anisoplanatism modes for MCAO</li>
     <li>Leaky integrator control law, up to 10th order <font class="new">NEW</font></li>
     <li>DM Hysteresis</li>
     <li>DM saturation</li>
     <li>Separate loop gain per DM</li>
     <li>Adjustable DM sensitivity (micron/volt) to hook to real systems</li>
     <li>Adjustable subaperture and actuator validation thresholds</li>
     <li>Various reconstructors: least-square with truncation (SVD)
     and MMSE-like. MMSE can use either full matrix or sparse methods
     (fast). Users can hook into yao and use their own code to compute
     the reconstructor <font class="new">NEW</font></li> 
     <li>Adjustable multi-wavelength, multi-position performance estimate</li>
     <li>"Skip and reset" along the phase screens at adjustable interval, to reach statistically significant performance estimates faster</li>
     <li>Uplink tip-tilt correction for LGS</li>
     <li>Adjustable LGS Elongation</li>
     <li>Rayleigh Fratricide effect for multiple sodium beacon systems</li>
     <li>Extrapolated actuators</li>
     <li>Centroid Gain optimization, using LGS dithering (only for LGS + Shack-Hartmann)</li>
     <li>Parametrizable vibration spectrum: white, 1/f, peaks with adjustable rms and width <font class="new">NEW</font>
     <li>Lots of internal variables are accessible from the outside of the program for debugging/implementation of new features</li>
   </ul>
   <h3>Comments and shorcomings</h3>
   <ul class="spaced">
     <li>Dependency on <font class="highlight">FFTW</font> for the
     fast FFT C implementation.</li>
     <li>Dependencies on the following yorick packages: yutils
     (general utilities), imutil (image manipulation), soy (sparse operations with yorick)</li>
     <li>The set-up routines (aoinit) have not yet been optimized for speed, thus, in particular, inverting large matrices can take some time. This optimization may come in due time, if deemed necessary.</li>
     <li>
       <font class="highlight">There is no GUI to configure the systems</font>. The parfile has to be edited manually, which in my view is not a big deal and actually allows for more compact &amp; clever parfiles, as yorick loops can be used to set repetitive variables.
     </li>
     <li>Some work has been done with pyramid WFS but no has not been maintained and does not work in the current version
     </li>
     <li>Scintillation is not supported, as it has been shown by many studies to be negligible at NIR wavelengths.
     </li>
     <li>Command matrices are up to now computed as least-square estimates. Implementation of minimum-variance or MAP should come shortly.
     </li>
   </ul><a name="start" id="start"></a>
 
   <h2>Where to start?</h2>
   Browse this site. Have a look at the <a href="manual.html">manual</a>. If you like what you see, go to the <a href="installation.html">Installation</a> page and follow the instructions.
   <p>Once the package is installed, follow the manual instruction, and use the examples parameter files to create your own parfile to model your system.</p>
  </div>
</div>


<div id="footer">
<div id="footer-left"><img src="images/kbkfooterleft.jpg"></div>
<div id="footer-right"><img src="images/kbkfooterright.jpg"></div>  
<div id="footer-center"></div>
</div>

</body>
</html>
